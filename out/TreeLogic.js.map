{"version":3,"sources":["..\\TreeLogic.fs"],"names":[],"mappings":"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","file":"TreeLogic.js","sourcesContent":["ï»¿module TreeLogic\r\n\r\nopen Types\r\n\r\n//helper functions\r\nlet self k tree =\r\n    tree |> Array.find (fun x -> k = x.key)\r\n\r\nlet ancestors k tree =\r\n    let rec ann k2 tree2 nodes = //exluding root\r\n        let x = (self k2 tree2)\r\n        match x.ntype with \r\n        | TRoot -> nodes\r\n        | _ -> ann x.parent tree2 (x::nodes)\r\n    ann k tree [] |> List.toArray \r\n\r\nlet children k tree =\r\n    tree |> Array.filter (fun x -> x.parent = k)\r\n\r\nlet parent k tree =\r\n    let p = k.parent\r\n    tree |> Array.find (fun x -> x.key = p)\r\n\r\nlet leafs2 tree =\r\n    tree |> Array.filter (fun x -> match x.ntype with\r\n                                    | TRoot -> false\r\n                                    | TLeaf -> true\r\n                                    | TBranch -> false)\r\n\r\nlet rec leafs k tree =\r\n    Array.collect (fun x -> match x.ntype with \r\n                            | TLeaf -> Array.singleton x\r\n                            | TBranch -> leafs k tree\r\n                            | TRoot -> Array.empty ) (children k tree)\r\n\r\n\r\n\r\nlet root tree =\r\n    tree |> Array.find (fun x -> match x.ntype with\r\n                                    | TRoot-> true\r\n                                    | TLeaf -> false\r\n                                    | TBranch -> false)\r\n\r\nlet depth k tree =\r\n    let l1 = (ancestors k tree).Length\r\n    let l2 = (children k tree) |> Array.fold (fun max x -> greater (ancestors k tree).Length max) 0\r\n    (l1+1,l2+1)\r\n\r\nlet size t =\r\n     let lfs = (leafs2 t)\r\n     (Array.fold (fun acc x -> greater x.size.get acc ) 0.0 lfs) + (Array.head lfs).data.distance\r\n\r\nlet size_ext n = n.extsize\r\n\r\n\r\n//calculate sizes and realtive scaling factor\r\nlet calc_sizes p tree =\r\n    for x in tree do\r\n        let multi = match x.ntype with\r\n                    | TRoot -> 1.0\r\n                    | TLeaf -> p.parent_to_children_scaling\r\n                    | TBranch -> let depth = depth x.key tree\r\n                                 p.parent_to_children_scaling * (1.0 + (float (fst depth))/(float (snd depth)))\r\n        x.data.scale <- multi\r\n    tree\r\n\r\n//populate angular resoultion\r\nlet calc_ar p tree =\r\n    let metric k = Array.sumBy (fun x -> x.size.get*x.data.scale) (leafs k tree)\r\n    let rec arinternal k (mp :float) (arp :float<rad>) = \r\n        Array.collect (fun x -> let mx = (metric x.key)\r\n                                let arx = (arp/mp * mx)\r\n                                [|(x.data.ar <- arx; x)|] |+| (arinternal x.key mx arx)) (children k tree) \r\n    let root = (root tree)\r\n    [|(root.data.ar <-tau; root)|] |+| (arinternal root.key (metric root.key) tau )\r\n\r\n\r\n//populate angles\r\nlet calc_theta p tree =\r\n    let rec ctheta k theata =\r\n        (children k tree) |> p.sort \r\n                          |> Array.mapFold (fun th x -> (x.data.angle<-th+0.5*x.data.ar;x,th+x.data.ar) ) theata\r\n                          |> fst\r\n                          |> Array.collect (fun x -> match x.ntype with\r\n                                                        | TBranch -> ctheta x.key (x.data.angle - 0.5*x.data.ar)\r\n                                                        | _-> Array.singleton x ) \r\n    ctheta (root tree).key 0.0<rad> |+| Array.singleton (root tree)\r\n\r\n//populate distances\r\nlet calc_d p tree =\r\n    let size_r = (root tree).size.get*(root tree).data.scale\r\n    let qx q = cos(q.data.angle)*q.data.distance\r\n    let qy q = sin(q.data.angle)*q.data.distance\r\n    let cd n t = \r\n        let d1 = n.size.get*n.data.scale + size_r\r\n        let d2 = if n.data.ar > tau/4.0 || n.data.ar = 0.0<rad> then 0.0 else n.size.get / (sin(n.data.ar / 2.0))\r\n        let d3 = (parent n t).data.distance\r\n        let d4 = (ancestors n.key t) |> Array.map (fun x -> (qx x)*cos(n.data.angle) + \r\n                                                               (qy x)*sin(n.data.angle) +\r\n                                                               sqrt( sqr(n.size.get*n.data.scale+x.size.get*x.data.scale) - sqr((qx x)*sin(n.data.angle) - (qy x)*cos(n.data.angle)) ))\r\n        ([|d1;d2;d3|] |+| d4) |> Array.fold greater 0.0\r\n\r\n    let rec calc_min k t = //error\r\n        let tre = t |> Array.map (fun x -> if x.parent = k then x.data.distance<-cd x t; x else x)\r\n        (children k tre) |> Array.collect (fun x -> match x.ntype with\r\n                                                      | TBranch -> calc_min x.key t\r\n                                                      | _ -> Array.singleton x)  \r\n    let temp = tree |> calc_min (root tree).key\r\n    let d_leaf = temp |> Array.fold (fun max x -> greater max x.data.distance) 0.0\r\n    [|(root tree)|] |+| temp |> Array.map (fun x -> match x.ntype with\r\n                                                    | TLeaf -> x.data.distance<-d_leaf; x\r\n                                                    | _ -> x )\r\n\r\n//clean rare intersection cases\r\nlet clean_intersections p tree =\r\n    tree\r\n\r\nlet calc_rel_position p tree =\r\n    tree |> Array.map (fun x -> x.data.pos <- (cos(x.data.angle)*x.data.distance,sin(x.data.angle)*x.data.distance) ; x)\r\n\r\n\r\n\r\nlet calc_tree p tree =\r\n    tree |> calc_sizes p\r\n         |> calc_ar p\r\n         |> calc_theta p\r\n         |> calc_d p\r\n         |> clean_intersections p\r\n         |> calc_rel_position p\r\n\r\nlet rec dfs_calc_tree p tree  =\r\n    tree |> Array.map (fun x -> \r\n        match x.element with\r\n        | Tree(t) ->  let t3 = dfs_calc_tree p t \r\n                      x.element<-Tree(t3)\r\n                      x.extsize.set (size t3)\r\n                      x\r\n        | _ -> x ) |> calc_tree p\r\n\r\nlet rec map_absolute_pos_scale p ((x,y),scale) tree  =\r\n    tree |> Array.map (fun n ->\r\n        let acc = (x+(fst n.data.pos),y+(snd n.data.pos)),scale*n.data.scale\r\n        n.position.set (fst acc)\r\n        printfn \"abs pos %f %f\" (fst (fst acc)) (snd (fst acc))\r\n        n.scale.set (snd acc)\r\n        match n.element with\r\n        | Tree(t) -> {n with element=Tree(map_absolute_pos_scale p acc t)}\r\n        | _ -> n )\r\n    \r\n\r\nlet calc_abs_position_scale p tree =\r\n    map_absolute_pos_scale p ((0.0,0.0),1.0) tree\r\n        \r\nlet render_tree p tree =\r\n    tree |> dfs_calc_tree p |> calc_abs_position_scale p\r\n \r\nlet calc_leafs (p :Params) tree =\r\n    let big = tree |> Array.map (fun x -> match x.element with\r\n                                            | Tree(t) -> t\r\n                                            | _ -> Array.singleton x) |> Array.concat\r\n    let rec dig k d tree =\r\n        let c =  children k.key tree\r\n        let c2 = c |> Array.map (fun x -> dig x (d+1) tree) |> Array.concat\r\n        if c.Length > p.div_tree_threshold then\r\n            k.ntype <- TLeaf\r\n            k.element <- Tree c2\r\n        else if c.Length > 0 then\r\n            k.ntype <- TBranch\r\n        else\r\n            k.ntype <- TLeaf\r\n        [|k|] |+| c2\r\n    dig (root tree) 0 big\r\n\r\n"]}