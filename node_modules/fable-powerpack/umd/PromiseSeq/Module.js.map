{"version":3,"sources":["../../../src/PromiseSeq/Module.fs"],"names":[],"mappings":"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","file":"Module.js","sourcesContent":["// ----------------------------------------------------------------------------\n// F# promise extensions (PromiseSeq.fs)\n// (c) Tomas Petricek, 2011, Available under Apache 2.0 license.\n// ----------------------------------------------------------------------------\nnamespace Fable.PowerPack\n\nopen System\nopen Fable.Import\n\n/// Module with helper functions for working with asynchronous sequences\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule PromiseSeq =\n\n  /// Creates an empty asynchronou sequence that immediately ends\n  [<GeneralizableValue>]\n  let empty<'T> : PromiseSeq<'T> =\n    Promise.lift Nil\n\n  /// Creates an asynchronous sequence that generates a single element and then ends\n  let singleton (v:'T) : PromiseSeq<'T> =\n    Promise.lift (Cons(v, empty))\n\n  /// Yields all elements of the first asynchronous sequence and then\n  /// all elements of the second asynchronous sequence.\n  let rec append (seq1: PromiseSeq<'T>) (seq2: PromiseSeq<'T>) : PromiseSeq<'T> =\n    promise { let! v1 = seq1\n            match v1 with\n            | Nil -> return! seq2\n            | Cons (h,t) -> return Cons(h,append t seq2) }\n\n\n  /// Computation builder that allows creating of asynchronous\n  /// sequences using the 'promiseSeq { ... }' syntax\n  type PromiseSeqBuilder() =\n    member x.Yield(v) = singleton v\n    // This looks weird, but it is needed to allow:\n    //\n    //   while foo do\n    //     do! something\n    //\n    // because F# translates body as Bind(something, fun () -> Return())\n    member x.Return(()) = empty\n    member x.YieldFrom(s) = s\n    member x.Zero () = empty\n    member x.Bind (inp:JS.Promise<'T>, body : 'T -> PromiseSeq<'U>) : PromiseSeq<'U> =\n      promise.Bind(inp, body)\n    member x.Combine (seq1:PromiseSeq<'T>,seq2:PromiseSeq<'T>) =\n      append seq1 seq2\n    member x.While (gd, seq:PromiseSeq<'T>) =\n      if gd() then x.Combine(seq,x.Delay(fun () -> x.While (gd, seq))) else x.Zero()\n    member x.Delay (f:unit -> PromiseSeq<'T>) =\n      promise.Delay(f)\n\n\n  /// Builds an asynchronou sequence using the computation builder syntax\n  let promiseSeq = new PromiseSeqBuilder()\n\n  /// Tries to get the next element of an asynchronous sequence\n  /// and returns either the value or an exception\n  let internal tryNext (input:PromiseSeq<_>) = promise {\n    try\n      let! v = input\n      return Choice1Of2 v\n    with e ->\n      return Choice2Of2 e }\n\n  /// Implements the 'TryWith' functionality for computation builder\n  let rec internal tryWith (input : PromiseSeq<'T>) handler =  promiseSeq {\n    let! v = tryNext input\n    match v with\n    | Choice1Of2 Nil -> ()\n    | Choice1Of2 (Cons (h, t)) ->\n        yield h\n        yield! tryWith t handler\n    | Choice2Of2 rest ->\n        yield! handler rest }\n\n  /// Implements the 'TryFinally' functionality for computation builder\n  let rec internal tryFinally (input : PromiseSeq<'T>) compensation = promiseSeq {\n    let! v = tryNext input\n    match v with\n    | Choice1Of2 Nil ->\n        compensation()\n    | Choice1Of2 (Cons (h, t)) ->\n        yield h\n        yield! tryFinally t compensation\n    | Choice2Of2 e ->\n        compensation()\n        yield! raise e }\n\n  /// Creates an asynchronou sequence that iterates over the given input sequence.\n  /// For every input element, it calls the the specified function and iterates\n  /// over all elements generated by that asynchronous sequence.\n  /// This is the 'bind' operation of the computation expression (exposed using\n  /// the 'for' keyword in promiseSeq computation).\n  let rec collect f (input : PromiseSeq<'T>) : PromiseSeq<'TResult> = promiseSeq {\n    let! v = input\n    match v with\n    | Nil -> ()\n    | Cons(h, t) ->\n        yield! f h\n        yield! collect f t }\n\n\n  // Add additional methods to the 'promiseSeq' computation builder\n  type PromiseSeqBuilder with\n    member x.TryFinally (body: PromiseSeq<'T>, compensation) =\n      tryFinally body compensation\n    member x.TryWith (body: PromiseSeq<_>, handler: (exn -> PromiseSeq<_>)) =\n      tryWith body handler\n    member x.Using (resource:#IDisposable, binder) =\n      tryFinally (binder resource) (fun () ->\n        if box resource <> null then resource.Dispose())\n\n    /// For loop that iterates over a synchronous sequence (and generates\n    /// all elements generated by the asynchronous body)\n    member x.For(seq:seq<'T>, action:'T -> PromiseSeq<'TResult>) =\n      let mutable cur = Unchecked.defaultof<_>\n      let enum: JS.Iterator<'T> = unbox(seq.GetEnumerator())\n      x.While(\n        (fun () -> cur <- enum.next(); not cur.``done``),\n        x.Delay(fun () -> action cur.value.Value))\n\n    /// Asynchronous for loop - for all elements from the input sequence,\n    /// generate all elements produced by the body (asynchronously). See\n    /// also the PromiseSeq.collect function.\n    member x.For (seq:PromiseSeq<'T>, action:'T -> PromiseSeq<'TResult>) =\n      collect action seq\n\n\n  // Add asynchronous for loop to the 'promise' computation builder\n  type Promise.PromiseBuilder with\n    member x.For (seq:PromiseSeq<'T>, action:'T -> JS.Promise<unit>) =\n      promise.Bind(seq, function\n        | Nil -> promise.Zero()\n        | Cons(h, t) -> promise.Combine(action h, x.For(t, action)))\n\n  // --------------------------------------------------------------------------\n  // Additional combinators (implemented as promise/promiseSeq computations)\n\n  /// Builds a new asynchronous sequence whose elements are generated by\n  /// applying the specified function to all elements of the input sequence.\n  ///\n  /// The specified function is asynchronous (and the input sequence will\n  /// be asked for the next element after the processing of an element completes).\n  let mapAsync f (input : PromiseSeq<'T>) : PromiseSeq<'TResult> = promiseSeq {\n    for itm in input do\n      let! v = f itm\n      yield v }\n\n  /// Asynchronously iterates over the input sequence and generates 'x' for\n  /// every input element for which the specified asynchronous function\n  /// returned 'Some(x)'\n  ///\n  /// The specified function is asynchronous (and the input sequence will\n  /// be asked for the next element after the processing of an element completes).\n  let chooseAsync f (input : PromiseSeq<'T>) : PromiseSeq<'R> = promiseSeq {\n    for itm in input do\n      let! v = f itm\n      match v with\n      | Some v -> yield v\n      | _ -> () }\n\n  /// Builds a new asynchronous sequence whose elements are those from the\n  /// input sequence for which the specified function returned true.\n  ///\n  /// The specified function is asynchronous (and the input sequence will\n  /// be asked for the next element after the processing of an element completes).\n  let filterAsync f (input : PromiseSeq<'T>) = promiseSeq {\n    for v in input do\n      let! b = f v\n      if b then yield v }\n\n  /// Asynchronously returns the last element that was generated by the\n  /// given asynchronous sequence (or the specified default value).\n  let rec lastOrDefault def (input : PromiseSeq<'T>) = promise {\n    let! v = input\n    match v with\n    | Nil -> return def\n    | Cons(h, t) -> return! lastOrDefault h t }\n\n  /// Asynchronously returns the first element that was generated by the\n  /// given asynchronous sequence (or the specified default value).\n  let firstOrDefault def (input : PromiseSeq<'T>) = promise {\n    let! v = input\n    match v with\n    | Nil -> return def\n    | Cons(h, _) -> return h }\n\n  /// Aggregates the elements of the input asynchronous sequence using the\n  /// specified 'aggregation' function. The result is an asynchronous\n  /// sequence of intermediate aggregation result.\n  ///\n  /// The aggregation function is asynchronous (and the input sequence will\n  /// be asked for the next element after the processing of an element completes).\n  let rec scanAsync f (state:'TState) (input : PromiseSeq<'T>) = promiseSeq {\n    let! v = input\n    match v with\n    | Nil -> ()\n    | Cons(h, t) ->\n        let! v = f state h\n        yield v\n        yield! t |> scanAsync f v }\n\n  /// Iterates over the input sequence and calls the specified function for\n  /// every value (to perform some side-effect asynchronously).\n  ///\n  /// The specified function is asynchronous (and the input sequence will\n  /// be asked for the next element after the processing of an element completes).\n  let rec iterAsync f (input : PromiseSeq<'T>) = promise {\n    for itm in input do\n      do! f itm }\n\n  /// Returns an asynchronous sequence that returns pairs containing an element\n  /// from the input sequence and its predecessor. Empty sequence is returned for\n  /// singleton input sequence.\n  let rec pairwise (input : PromiseSeq<'T>) = promiseSeq {\n    let! v = input\n    match v with\n    | Nil -> ()\n    | Cons(h, t) ->\n        let prev = ref h\n        for v in t do\n          yield (!prev, v)\n          prev := v }\n\n  /// Aggregates the elements of the input asynchronous sequence using the\n  /// specified 'aggregation' function. The result is an asynchronous\n  /// workflow that returns the final result.\n  ///\n  /// The aggregation function is asynchronous (and the input sequence will\n  /// be asked for the next element after the processing of an element completes).\n  let rec foldAsync f (state:'TState) (input : PromiseSeq<'T>) =\n    input |> scanAsync f state |> lastOrDefault state\n\n  /// Same as PromiseSeq.foldAsync, but the specified function is synchronous\n  /// and returns the result of aggregation immediately.\n  let rec fold f (state:'TState) (input : PromiseSeq<'T>) =\n    foldAsync (fun st v -> f st v |> promise.Return) state input\n\n  /// Same as PromiseSeq.scanAsync, but the specified function is synchronous\n  /// and returns the result of aggregation immediately.\n  let rec scan f (state:'TState) (input : PromiseSeq<'T>) =\n    scanAsync (fun st v -> f st v |> promise.Return) state input\n\n  /// Same as PromiseSeq.mapAsync, but the specified function is synchronous\n  /// and returns the result of projection immediately.\n  let map f (input : PromiseSeq<'T>) =\n    mapAsync (f >> promise.Return) input\n\n  /// Same as PromiseSeq.iterAsync, but the specified function is synchronous\n  /// and performs the side-effect immediately.\n  let iter f (input : PromiseSeq<'T>) =\n    iterAsync (f >> promise.Return) input\n\n  /// Same as PromiseSeq.chooseAsync, but the specified function is synchronous\n  /// and processes the input element immediately.\n  let choose f (input : PromiseSeq<'T>) =\n    chooseAsync (f >> promise.Return) input\n\n  /// Same as PromiseSeq.filterAsync, but the specified predicate is synchronous\n  /// and processes the input element immediately.\n  let filter f (input : PromiseSeq<'T>) =\n    filterAsync (f >> promise.Return) input\n\n  // /// Combines two asynchronous sequences into a sequence of pairs.\n  // /// The values from sequences are retrieved in parallel.\n  // let rec zip (input1 : PromiseSeq<'T1>) (input2 : PromiseSeq<'T2>) : PromiseSeq<_> = promise {\n  //   let! ft = input1 |> JS.Promise.StartChild\n  //   let! s = input2\n  //   let! f = ft\n  //   match f, s with\n  //   | Cons(hf, tf), Cons(hs, ts) ->\n  //       return Cons( (hf, hs), zip tf ts)\n  //   | _ -> return Nil }\n\n  /// Returns elements from an asynchronous sequence while the specified\n  /// predicate holds. The predicate is evaluated asynchronously.\n  let rec takeWhileAsync p (input : PromiseSeq<'T>) : PromiseSeq<_> = promise {\n    let! v = input\n    match v with\n    | Cons(h, t) ->\n        let! res = p h\n        if res then\n          return Cons(h, takeWhileAsync p t)\n        else return Nil\n    | Nil -> return Nil }\n\n  /// Skips elements from an asynchronous sequence while the specified\n  /// predicate holds and then returns the rest of the sequence. The\n  /// predicate is evaluated asynchronously.\n  let rec skipWhileAsync p (input : PromiseSeq<'T>) : PromiseSeq<_> = promise {\n    let! v = input\n    match v with\n    | Cons(h, t) ->\n        let! res = p h\n        if res then return! skipWhileAsync p t\n        else return! t\n    | Nil -> return Nil }\n\n  /// Returns elements from an asynchronous sequence while the specified\n  /// predicate holds. The predicate is evaluated synchronously.\n  let rec takeWhile p (input : PromiseSeq<'T>) =\n    takeWhileAsync (p >> promise.Return) input\n\n  /// Skips elements from an asynchronous sequence while the specified\n  /// predicate holds and then returns the rest of the sequence. The\n  /// predicate is evaluated asynchronously.\n  let rec skipWhile p (input : PromiseSeq<'T>) =\n    skipWhileAsync (p >> promise.Return) input\n\n  /// Returns the first N elements of an asynchronous sequence\n  let rec take count (input : PromiseSeq<'T>) : PromiseSeq<_> = promise {\n    if count > 0 then\n      let! v = input\n      match v with\n      | Cons(h, t) ->\n          return Cons(h, take (count - 1) t)\n      | Nil -> return Nil\n    else return Nil }\n\n  /// Skips the first N elements of an asynchronous sequence and\n  /// then returns the rest of the sequence unmodified.\n  let rec skip count (input : PromiseSeq<'T>) : PromiseSeq<_> = promise {\n    if count > 0 then\n      let! v = input\n      match v with\n      | Cons(h, t) ->\n          return! skip (count - 1) t\n      | Nil -> return Nil\n    else return! input }\n"]}