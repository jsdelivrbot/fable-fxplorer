function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { Promise as _Promise } from "./Promise";
import { toJson, ofJson } from "fable-core/Serialize";

function _fetch(url, init) {
    return fetch(url, init).then(function (response) {
        return response.ok ? response : function () {
            throw new Error(String(response.status) + " " + response.statusText + " for URL " + response.url);
        }();
    });
}

export { _fetch as fetch };
export function tryFetch(url, init) {
    return _Promise.result(_fetch(url, init));
}
export function fetchAs(url, init, _genArgs) {
    return _fetch(url, init).then(function (fetched) {
        return fetched.text();
    }).then(function (json) {
        return ofJson(json, {
            T: _genArgs.T
        });
    });
}
export function tryFetchAs(url, init, _genArgs) {
    return _Promise.result(fetchAs(url, init, {
        T: _genArgs.T
    }));
}
export function postRecord(url, record, properties) {
    var props = Object.assign({
        method: "POST",
        headers: _defineProperty({}, "Content-Type", "application/json"),
        body: toJson(record)
    }, properties);
    return _fetch(url, props);
}
export function tryPostRecord(url, record, properties) {
    return _Promise.result(postRecord(url, record, properties));
}
export function patchRecord(url, record, properties) {
    var props = Object.assign({
        method: "PATCH",
        headers: _defineProperty({}, "Content-Type", "application/json"),
        body: toJson(record)
    }, properties);
    return _fetch(url, props);
}
//# sourceMappingURL=Fetch.js.map