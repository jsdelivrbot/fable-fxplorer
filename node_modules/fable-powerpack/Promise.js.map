{"version":3,"sources":["../src/Promise.fs"],"names":[],"mappings":";;;;;;;;AAKO;AAqCC,oCACA;AAAA,sBAAO;AAAA;AAAA,SAAP,EAAU;AAAA;AAAA,SAAV;AAAiB,KADjB;;AAGA,0CACK;AAAA,sBAAK;AAAA;AAAA,SAAL;AAAmB,KADxB;;AAGA,4CACK;AAAA,sBACK;AAAA,0DAII,oCAJJ,IAEF,OAAQ,iBAAR,CAFE;AAAA,SADL;AAKkB,KANvB;;AAQC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,2CAWe;AAAI;AAAJ;AAAA;AAAA;;AAAA;AAAA;AAAA;AAER,4BAAO,OAAqB;AAAA;AAAA,yBAArB,CAAP;AAFQ;;AACZ,0KACI;AAAA;AAAmC;AAF3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAC;AAXhB;AAAA;AAAA,4CAiBG;AAAA;;AAAA,uBAAG,OAAH,UACqB;AAAA;AAAA,iBADrB;AAEW;AAnBd;AAAA;AAAA,wDA+BG;AAAA,8BAAiB;AAAA;AAAA;AAAiB,iBAAlC,EAA+C;AAAA;AAAgB;AAAU,iBAAzE;AAA4E;AA/B/E;AAAA;AAAA,6CAqCK;AAAA;AAEM;AAAA,4BAAI;AAAA;AAA2B,yBAA/B,CAEI;AAAA,gCAAG,UAAH,EACO;AAAA;AAAqB,6BAD5B,MAGI;AAAA,oCAAM;AAAA,2DAAmB,MAAnB;AAA0B,iCAAhC,CACa;AAAA;AAAqB;AAAA;AAAA;AAAA,qBARhD;AAUM;AAAA,4BAAI;AAAA;AAAoB,yBAAxB,CAEI;AAAA,gCAAM;AAAA,uDAAmB,KAAnB;AAAyB,6BAA/B,CACa;AAAA;AAAqB;AAAA;AAAA;AAb5C;AAcD;AAnDJ;AAAA;AAAA,oDAsDG;AAAA,uCAAa,gBAAb,EAAyC;AAAA;AAAkB,iBAA3D;AAA4D;AAtD/D;;AAAA;AAAA;;AAnDF;AAAA;AAwGe,CAxGf;;;AA4GA;AACC,sCAAU,6BAAV;AADD;AACQ,CADR","file":"Promise.js","sourcesContent":["namespace Fable.PowerPack\n\n#nowarn \"1182\" // Unused values\n\n[<RequireQualifiedAccess>]\nmodule Promise =\n    open System\n    open Fable.Core\n    open Fable.Import\n    open Fable.Core.JsInterop\n    open Fable.PowerPack.Result\n\n    let inline private (!!) (x:obj): 'T = unbox x\n\n    [<Emit(\"new Promise($0)\")>]\n    /// The promise function receives two other function parameters: success and fail\n    let create (f: ('T->unit)->(Exception->unit)->unit): JS.Promise<'T> = jsNative\n\n    [<Emit(\"new Promise(resolve => setTimeout(resolve, $0))\")>]\n    let sleep (ms: int): JS.Promise<unit> = jsNative\n\n    [<Emit(\"Promise.resolve($0)\")>]\n    let lift<'T> (a: 'T): JS.Promise<'T> = jsNative\n\n    [<Emit(\"$1.then($0)\")>]\n    let bind (a: 'T->JS.Promise<'R>) (pr: JS.Promise<'T>): JS.Promise<'R> = jsNative\n\n    [<Emit(\"$1.then($0)\")>]\n    let map (a: 'T->'R) (pr: JS.Promise<'T>): JS.Promise<'R> = jsNative\n\n    [<Emit(\"$1.then($0)\")>]\n    let iter (a: 'T->unit) (pr: JS.Promise<'T>): unit = jsNative\n\n    [<Emit(\"$1.catch($0)\")>]\n    let catch (a: Exception->'T) (pr: JS.Promise<'T>): JS.Promise<'T> = jsNative\n\n    [<Emit(\"$2.then($0,$1)\")>]\n    let either (success: 'T->'R) (fail: Exception->'R) (pr: JS.Promise<'T>): JS.Promise<'R> = jsNative\n\n    [<Emit(\"Promise.all($0)\")>]\n    let Parallel (pr: seq<JS.Promise<'T>>): JS.Promise<'T[]> = jsNative\n\n    let result (a: JS.Promise<'A>): JS.Promise<Result<'A, Exception>> =\n        either Ok Error a\n\n    let mapResult (fn: 'A -> 'B) (a: JS.Promise<Result<'A, 'E>>): JS.Promise<Result<'B, 'E>> =\n        a |> map (Result.map fn)\n\n    let bindResult (fn: 'A -> JS.Promise<'B>) (a: JS.Promise<Result<'A, Exception>>): JS.Promise<Result<'B, Exception>> =\n        a |> bind (fun a ->\n            match a with\n            | Ok a ->\n                result (fn a)\n            | Error e ->\n                lift (Error e))\n\n    type PromiseBuilder() =\n        [<Emit(\"$1.then($2)\")>]\n        member x.Bind(p: JS.Promise<'T>, f: 'T->JS.Promise<'R>): JS.Promise<'R> = jsNative\n\n        [<Emit(\"$1.then(() => $2)\")>]\n        member x.Combine(p1: JS.Promise<unit>, p2: JS.Promise<'T>): JS.Promise<'T> = jsNative\n\n        member x.For(seq: seq<'T>, body: 'T->JS.Promise<unit>): JS.Promise<unit> =\n            // (lift (), seq)\n            // ||> Seq.fold (fun p a ->\n            //     bind (fun () -> body a) p)\n            let mutable p = lift ()\n            for a in seq do\n                p <- !!p?``then``(fun () -> body a)\n            p\n\n        member x.While(guard, p): JS.Promise<unit> =\n            if guard()\n            then bind (fun () -> x.While(guard, p)) p\n            else lift()\n\n        [<Emit(\"Promise.resolve($1)\")>]\n        member x.Return(a: 'T): JS.Promise<'T> = jsNative\n\n        [<Emit(\"$1\")>]\n        member x.ReturnFrom(p: JS.Promise<'T>) = jsNative\n\n        [<Emit(\"Promise.resolve()\")>]\n        member x.Zero(): JS.Promise<unit> = jsNative\n\n        member x.TryFinally(p: JS.Promise<'T>, compensation: unit->unit) =\n            either (fun x -> compensation(); x) (fun er -> compensation(); raise !!er) p\n\n        [<Emit(\"$1.catch($2)\")>]\n        member x.TryWith(p: JS.Promise<'T>, catchHandler: Exception->JS.Promise<'T>): JS.Promise<'T> = jsNative\n\n        member x.Delay(generator: unit->JS.Promise<'T>): JS.Promise<'T> =\n            !!createObj[\n                \"then\" ==> fun f1 f2 ->\n                    try generator()?``then``(f1,f2)\n                    with er ->\n                        if box f2 = null\n                        then !!JS.Promise.reject(er)\n                        else\n                            try !!JS.Promise.resolve(f2(er))\n                            with er -> !!JS.Promise.reject(er)\n                \"catch\" ==> fun f ->\n                    try generator()?catch(f)\n                    with er ->\n                        try !!JS.Promise.resolve(f(er))\n                        with er -> !!JS.Promise.reject(er)\n            ]\n\n        member x.Using<'T, 'R when 'T :> IDisposable>(resource: 'T, binder: 'T->JS.Promise<'R>): JS.Promise<'R> =\n            x.TryFinally(binder(resource), fun () -> resource.Dispose())\n\n[<AutoOpen>]\nmodule PromiseImpl =\n    let promise = Promise.PromiseBuilder()\n"]}