{"version":3,"sources":["../src/IndexedDB.fs"],"names":[],"mappings":"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","file":"IndexedDB.js","sourcesContent":["module Fable.PowerPack.Experimental.IndexedDB\n\nopen Fable.Core\nopen Fable.Core.JsInterop\nopen Fable.Import\nopen Fable.PowerPack\n\ntype DBKeyMethod<'T,'TKey> =\n    | KeyPath of string\n    | AutoIncrement\n\ntype DBCursorDirection =\n    /// This direction causes the cursor to be opened at the start of the source.\n    /// When iterated, the cursor should yield all records, including duplicates, in monotonically increasing order of keys.\n    | Next\n    /// This direction causes the cursor to be opened at the start of the source.\n    /// When iterated, the cursor should not yield records with the same key, but otherwise yield all records, in monotonically increasing order of keys.\n    /// For every key with duplicate values, only the first record is yielded.\n    /// When the source is an object store or a unique index, this direction has the exact same behavior as Next.\n    | NextUnique\n    /// This direction causes the cursor to be opened at the end of the source.\n    /// When iterated, the cursor should yield all records, including duplicates, in monotonically decreasing order of keys.\n    | Prev\n    /// This direction causes the cursor to be opened at the end of the source.\n    /// When iterated, the cursor should not yield records with the same key, but otherwise yield all records, in monotonically decreasing order of keys.\n    /// For every key with duplicate values, only the first record is yielded.\n    /// When the source is an object store or a unique index, this direction has the exact same behavior as Prev.\n    | PrevUnique\n    static member Default with get() = Next\n    override dir.ToString() =\n        match dir with\n        | Next -> \"next\"\n        | NextUnique -> \"nextunique\"\n        | Prev -> \"prev\"\n        | PrevUnique -> \"prevunique\"\n\n[<PassGenerics>]\nlet createStore<'T,'TKey>(keyMethod: DBKeyMethod<'T,'TKey>) (db: Browser.IDBDatabase) =\n    let args = createEmpty<Browser.IDBObjectStoreParameters>\n    match keyMethod with\n    | KeyPath path -> args.keyPath <- Some(U2.Case1 path)\n    | AutoIncrement -> args.autoIncrement <- Some true\n    let storeName = typeof<'T>.Name\n    db.createObjectStore(storeName, args)\n\n[<PassGenerics>]\nlet deleteStore<'T>(db: Browser.IDBDatabase) =\n    let storeName = typeof<'T>.Name\n    db.deleteObjectStore(storeName)\n\ntype IDBImplementation =\n    abstract member Version: uint32\n    abstract member Upgrade: Browser.IDBDatabase -> unit\n\nlet openCursor(index: Browser.IDBIndex, keyCursor: bool, range: Browser.IDBKeyRange option, direction: DBCursorDirection option, step: uint32 option) =\n    let range = defaultArg range Unchecked.defaultof<Browser.IDBKeyRange>\n    let direction = (defaultArg direction DBCursorDirection.Default).ToString()\n    let step = defaultArg step 1u\n    let request =\n        match keyCursor with\n        | false -> index.openCursor(range, direction)\n        | true -> index.openKeyCursor(range, direction)\n    let rec cursorSeq() = promiseSeq {\n        let! result = Promise.create(fun cont _ ->\n            request.onsuccess <- fun _ ->\n                request.onsuccess <- null\n                if unbox<bool> request.result then\n                    let cursor = unbox<Browser.IDBCursorWithValue> request.result\n                    cont(Some(unbox<'T> cursor.value))\n                    cursor.advance(float step)\n                else\n                    cont(None)\n                null)\n        match result with\n        | None -> ()\n        | Some r ->\n            yield r\n            yield! cursorSeq()\n    }\n    cursorSeq()\n\nlet countAllAsync(x: Browser.IDBIndex) =\n    Promise.create(fun cont econt ->\n        let request = x.count()\n        request.onerror <- fun _ -> box(econt(exn request.error.name))\n        request.onsuccess <- fun _ -> box(cont(unbox<int> request.result))\n    )\n\n/// The parameter should not target the object primary key, but the property used by the index.\nlet countKeyAsync(indexKey: 'TIndex) (x: Browser.IDBIndex) =\n    Promise.create(fun cont econt ->\n        let request = x.count(indexKey)\n        request.onerror <- fun _ -> box(econt(exn request.error.name))\n        request.onsuccess <- fun _ -> box(cont(unbox<int> request.result))\n    )\n\n/// The parameter should not target the object primary key, but the property used by the index.\nlet countRangeAsync(indexKeyRange: Browser.IDBKeyRange) (x: Browser.IDBIndex) =\n    Promise.create(fun cont econt ->\n        let request = x.count(indexKeyRange)\n        request.onerror <- fun _ -> box(econt(exn request.error.name))\n        request.onsuccess <- fun _ -> box(cont(unbox<int> request.result))\n    )\n\n/// The parameter should not target the object primary key, but the property used by the index.\nlet getAsync(indexKey: 'TIndex) (x: Browser.IDBIndex) =\n    Promise.create(fun cont econt ->\n        let request = x.get(indexKey)\n        request.onerror <- fun _ -> box(econt(exn request.error.name))\n        request.onsuccess <- fun _ -> box(cont(unbox<'T> request.result))\n    )\n\n/// The parameter should not target the object primary key, but the property used by the index.\nlet getFirstAsync(indexKeyRange: Browser.IDBKeyRange) (x: Browser.IDBIndex) =\n    Promise.create(fun cont econt ->\n        let request = x.get(indexKeyRange)\n        request.onerror <- fun _ -> box(econt(exn request.error.name))\n        request.onsuccess <- fun _ -> box(cont(unbox<'T> request.result))\n    )\n\n/// The parameter should not target the object primary key, but the property used by the index.\n/// The return value is the object actual primary key.\nlet getKeyAsync(indexKey: obj) (x: Browser.IDBIndex) =\n    Promise.create(fun cont econt ->\n        let request = x.getKey(indexKey)\n        request.onerror <- fun _ -> box(econt(exn request.error.name))\n        request.onsuccess <- fun _ -> box(cont(request.result))\n    )\n\n/// The parameter should not target the object primary key, but the property used by the index.\n/// The return value is the object actual primary key.\nlet getKeyFirstAsync(indexKeyRange: Browser.IDBKeyRange) (x: Browser.IDBIndex) =\n    Promise.create(fun cont econt ->\n        let request = x.getKey(indexKeyRange)\n        request.onerror <- fun _ -> box(econt(exn request.error.name))\n        request.onsuccess <- fun _ -> box(cont(request.result))\n    )\n\n// /// If no range is passed, then the range includes all records.\n// /// If no direction is passed, it will default to \"next\".\n// member x.openCursor(?range: Browser.IDBKeyRange, ?direction: DBCursorDirection, ?step: uint32) =\n//     DBSeqCursor<'T>.openCursor(unbox x, keyCursor=false, range=range, direction=direction, step=step)\n\n// /// If no range is passed, then the range includes all keys.\n// /// If no direction is passed, it will default to \"next\".\n// member x.openKeyCursor(?range: Browser.IDBKeyRange, ?direction: DBCursorDirection, ?step: uint32) =\n//     DBSeqCursor<obj>.openCursor(unbox x, keyCursor=true, range=range, direction=direction, step=step)\n\ntype Browser.IDBObjectStore with\n    member x.getAsync<'T>(key: obj) =\n        Promise.create(fun cont econt ->\n            let request = x.get(key)\n            request.onerror <- fun _ -> box(econt(exn request.error.name))\n            request.onsuccess <- fun _ -> box(cont(unbox<'T> request.result))\n        )\n\n    /// If no range is passed, it will default to a key range that selects all the records in this object store.\n    /// If no direction is passed, it will default to \"next\".\n    member x.openCursorAsync(?range: Browser.IDBKeyRange, ?direction: DBCursorDirection, ?step: uint32) =\n        openCursor(unbox x, false, range, direction, step)\n\n    // /// Insert only method. The operation is asynchronous but request is being ignored.\n    // member x.add(item: 'T) =\n    //     ignore(x.add(item))\n\n    /// Insert only method. It can be used in promise workflows. The return value is key set for the stored record.\n    /// Note the continuation is called when the operation is added to the queue, but you still need to wait for the transaction to complete.\n    member x.addAsync(item: 'T) =\n        Promise.create(fun cont econt ->\n            let request = x.add(item)\n            request.onerror <- fun _ -> box(econt(exn request.error.name))\n            request.onsuccess <- fun _ -> box(cont(request.result))\n        )\n\n    // /// Delete the item specified by the key. The operation is asynchronous but request is being ignored.\n    // member x.delete(key: obj) =\n    //     ignore(x.delete(key))\n\n    /// Delete the item specified by the key. It can be used in promise workflows.\n    /// Note the continuation is called when the operation is added to the queue, but you still need to wait for the transaction to complete.\n    member x.deleteAsync(key: obj) =\n        Promise.create(fun cont econt ->\n            let request = x.delete(key)\n            request.onerror <- fun _ -> box(econt(exn request.error.name))\n            request.onsuccess <- fun _ -> box(cont())\n        )\n\n    // /// Delete all items in the store. The operation is asynchronous but request is being ignored.\n    // member x.clear() =\n    //     ignore(x.clear())\n\n    /// Delete all items in the store. It can be used in promise workflows.\n    /// Note the continuation is called when the operation is added to the queue, but you still need to wait for the transaction to complete.\n    member x.clearAsync() =\n        Promise.create(fun cont econt ->\n            let request = x.clear()\n            request.onerror <- fun _ -> box(econt(exn request.error.name))\n            request.onsuccess <- fun _ -> box(cont())\n        )\n\n    // /// Update or Insert method. The operation is asynchronous but request is being ignored.\n    // member x.put(item: 'T) =\n    //     ignore(x.put(item))\n\n    /// Update or insert method. It can be used in promise workflows. The return value is key set for the stored record.\n    /// Note the continuation is called when the operation is added to the queue, but you still need to wait for the transaction to complete.\n    member x.putAsync(item: 'T) =\n        Promise.create(fun cont econt ->\n            let request = x.put(item)\n            request.onerror <- fun _ -> box(econt(exn request.error.name))\n            request.onsuccess <- fun _ -> box(cont(request.result))\n        )\n\ntype IndexedDB<'T when 'T :> IDBImplementation and 'T : (new: unit->'T)>() =\n    [<PassGenerics>]\n    member x.DeleteDatabase() =\n        Promise.create(fun cont econt ->\n            let name = typeof<'T>.Name\n            let request = Browser.indexedDB.deleteDatabase(name)\n            request.onerror <- fun _ -> box(econt(exn request.error.name))\n            request.onsuccess <- fun _ -> box(cont())\n        )\n    [<PassGenerics>]\n    member private x.Use(mkTransaction: Browser.IDBDatabase->Browser.IDBTransaction) (execTransaction: Browser.IDBTransaction->JS.Promise<'Result>) =\n        Promise.create(fun cont econt ->\n            let impl = new 'T() :> IDBImplementation\n            let name = typeof<'T>.Name\n            let request = Browser.indexedDB.``open``(name, float impl.Version)\n            request.onerror <- fun _ ->\n                econt(exn request.error.name)\n                null\n            request.onupgradeneeded <- fun ev ->\n                try\n                    let db = unbox<Browser.IDBDatabase> request.result\n                    impl.Upgrade(db)\n                with\n                    | e -> econt(e)\n                null\n            request.onsuccess <- fun _ ->\n                try\n                    let db = unbox<Browser.IDBDatabase> request.result\n                    let trans = mkTransaction db\n                    execTransaction trans\n                    |> Promise.map (fun res ->\n                        trans.oncomplete <- fun _ -> db.close(); box(cont(res))\n                        trans.onerror <- fun _ -> db.close(); box(econt(exn trans.error.name)))\n                    |> Promise.catch econt\n                    |> ignore\n                with\n                | e -> econt(e)\n                null\n        )\n    [<PassGenerics; CompiledName(\"UseStoreReadOnly1\")>]\n    member x.UseStore<'S1,'Result>(transaction: Browser.IDBObjectStore->JS.Promise<'Result>) =\n        let storeName1 = typeof<'S1>.Name\n        let mkTransaction = fun (db: Browser.IDBDatabase) ->\n            db.transaction(U2.Case1 storeName1, \"readonly\")\n        let execTransaction = fun (trans: Browser.IDBTransaction) ->\n            let store1 = trans.objectStore(storeName1)\n            transaction store1\n        x.Use mkTransaction execTransaction\n    [<PassGenerics; CompiledName(\"UseStoreReadOnly2\")>]\n    member x.UseStore<'S1,'S2,'Result>(transaction: Browser.IDBObjectStore->Browser.IDBObjectStore->JS.Promise<'Result>) =\n        let storeName1 = typeof<'S1>.Name\n        let storeName2 = typeof<'S2>.Name\n        let mkTransaction = fun (db: Browser.IDBDatabase) ->\n            db.transaction(U2.Case2(ResizeArray[|storeName1;storeName2|]), \"readonly\")\n        let execTransaction = fun (trans: Browser.IDBTransaction) ->\n            let store1 = trans.objectStore(storeName1)\n            let store2 = trans.objectStore(storeName2)\n            transaction store1 store2\n        x.Use mkTransaction execTransaction\n    [<PassGenerics; CompiledName(\"UseStoreReadOnly3\")>]\n    member x.UseStore<'S1,'S2,'S3,'Result>(transaction: Browser.IDBObjectStore->Browser.IDBObjectStore->Browser.IDBObjectStore->JS.Promise<'Result>) =\n        let storeName1 = typeof<'S1>.Name\n        let storeName2 = typeof<'S2>.Name\n        let storeName3 = typeof<'S3>.Name\n        let mkTransaction = fun (db: Browser.IDBDatabase) ->\n            db.transaction(U2.Case2(ResizeArray[|storeName1;storeName2;storeName3|]), \"readonly\")\n        let execTransaction = fun (trans: Browser.IDBTransaction) ->\n            let store1 = trans.objectStore(storeName1)\n            let store2 = trans.objectStore(storeName2)\n            let store3 = trans.objectStore(storeName3)\n            transaction store1 store2 store3\n        x.Use mkTransaction execTransaction\n    [<PassGenerics; CompiledName(\"UseStoreReadOnly4\")>]\n    member x.UseStore<'S1,'S2,'S3,'S4,'Result>(transaction: Browser.IDBObjectStore->Browser.IDBObjectStore->Browser.IDBObjectStore->Browser.IDBObjectStore->JS.Promise<'Result>) =\n        let storeName1 = typeof<'S1>.Name\n        let storeName2 = typeof<'S2>.Name\n        let storeName3 = typeof<'S3>.Name\n        let storeName4 = typeof<'S4>.Name\n        let mkTransaction = fun (db: Browser.IDBDatabase) ->\n            db.transaction(U2.Case2(ResizeArray[|storeName1;storeName2;storeName3;storeName4|]), \"readonly\")\n        let execTransaction = fun (trans: Browser.IDBTransaction) ->\n            let store1 = trans.objectStore(storeName1)\n            let store2 = trans.objectStore(storeName2)\n            let store3 = trans.objectStore(storeName3)\n            let store4 = trans.objectStore(storeName4)\n            transaction store1 store2 store3 store4\n        x.Use mkTransaction execTransaction\n\n    [<PassGenerics; CompiledName(\"UseStoreReadWrite1\")>]\n    member x.UseStoreRW<'S1,'Result>(transaction: Browser.IDBObjectStore->JS.Promise<'Result>) =\n        let storeName1 = typeof<'S1>.Name\n        let mkTransaction = fun (db: Browser.IDBDatabase) ->\n            db.transaction(U2.Case1 storeName1, \"readwrite\")\n        let execTransaction = fun (trans: Browser.IDBTransaction) ->\n            let store1 = trans.objectStore(storeName1)\n            transaction store1\n        x.Use mkTransaction execTransaction\n\n    [<PassGenerics; CompiledName(\"UseStoreReadWrite2\")>]\n    member x.UseStoreRW<'S1,'S2,'Result>(transaction: Browser.IDBObjectStore->Browser.IDBObjectStore->JS.Promise<'Result>) =\n        let storeName1 = typeof<'S1>.Name\n        let storeName2 = typeof<'S2>.Name\n        let mkTransaction = fun (db: Browser.IDBDatabase) ->\n            db.transaction(U2.Case2(ResizeArray[|storeName1; storeName2|]), \"readwrite\")\n        let execTransaction = fun (trans: Browser.IDBTransaction) ->\n            let store1 = trans.objectStore(storeName1)\n            let store2 = trans.objectStore(storeName2)\n            transaction store1 store2\n        x.Use mkTransaction execTransaction\n\n    [<PassGenerics; CompiledName(\"UseStoreReadWrite3\")>]\n    member x.UseStoreRW<'S1,'S2,'S3,'Result>(transaction: Browser.IDBObjectStore->Browser.IDBObjectStore->Browser.IDBObjectStore->JS.Promise<'Result>) =\n        let storeName1 = typeof<'S1>.Name\n        let storeName2 = typeof<'S2>.Name\n        let storeName3 = typeof<'S3>.Name\n        let mkTransaction = fun (db: Browser.IDBDatabase) ->\n            db.transaction(U2.Case2(ResizeArray[|storeName1;storeName2;storeName3|]), \"readwrite\")\n        let execTransaction = fun (trans: Browser.IDBTransaction) ->\n            let store1 = trans.objectStore(storeName1)\n            let store2 = trans.objectStore(storeName2)\n            let store3 = trans.objectStore(storeName3)\n            transaction store1 store2 store3\n        x.Use mkTransaction execTransaction\n    [<PassGenerics; CompiledName(\"UseStoreReadWrite4\")>]\n    member x.UseStoreRW<'S1,'S2,'S3,'S4,'Result>(transaction: Browser.IDBObjectStore->Browser.IDBObjectStore->Browser.IDBObjectStore->Browser.IDBObjectStore->JS.Promise<'Result>) =\n        let storeName1 = typeof<'S1>.Name\n        let storeName2 = typeof<'S2>.Name\n        let storeName3 = typeof<'S3>.Name\n        let storeName4 = typeof<'S4>.Name\n        let mkTransaction = fun (db: Browser.IDBDatabase) ->\n            db.transaction(U2.Case2(ResizeArray[|storeName1;storeName2;storeName3;storeName4|]), \"readwrite\")\n        let execTransaction = fun (trans: Browser.IDBTransaction) ->\n            let store1 = trans.objectStore(storeName1)\n            let store2 = trans.objectStore(storeName2)\n            let store3 = trans.objectStore(storeName3)\n            let store4 = trans.objectStore(storeName4)\n            transaction store1 store2 store3 store4\n        x.Use mkTransaction execTransaction"]}