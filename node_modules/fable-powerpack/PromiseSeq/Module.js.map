{"version":3,"sources":["../../src/PromiseSeq/Module.fs"],"names":[],"mappings":"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","file":"Module.js","sourcesContent":["// ----------------------------------------------------------------------------\n// F# promise extensions (PromiseSeq.fs)\n// (c) Tomas Petricek, 2011, Available under Apache 2.0 license.\n// ----------------------------------------------------------------------------\nnamespace Fable.PowerPack\n\nopen System\nopen Fable.Import\n\n/// Module with helper functions for working with asynchronous sequences\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule PromiseSeq =\n\n  /// Creates an empty asynchronou sequence that immediately ends\n  [<GeneralizableValue>]\n  let empty<'T> : PromiseSeq<'T> =\n    Promise.lift Nil\n\n  /// Creates an asynchronous sequence that generates a single element and then ends\n  let singleton (v:'T) : PromiseSeq<'T> =\n    Promise.lift (Cons(v, empty))\n\n  /// Yields all elements of the first asynchronous sequence and then\n  /// all elements of the second asynchronous sequence.\n  let rec append (seq1: PromiseSeq<'T>) (seq2: PromiseSeq<'T>) : PromiseSeq<'T> =\n    promise { let! v1 = seq1\n            match v1 with\n            | Nil -> return! seq2\n            | Cons (h,t) -> return Cons(h,append t seq2) }\n\n\n  /// Computation builder that allows creating of asynchronous\n  /// sequences using the 'promiseSeq { ... }' syntax\n  type PromiseSeqBuilder() =\n    member x.Yield(v) = singleton v\n    // This looks weird, but it is needed to allow:\n    //\n    //   while foo do\n    //     do! something\n    //\n    // because F# translates body as Bind(something, fun () -> Return())\n    member x.Return(()) = empty\n    member x.YieldFrom(s) = s\n    member x.Zero () = empty\n    member x.Bind (inp:JS.Promise<'T>, body : 'T -> PromiseSeq<'U>) : PromiseSeq<'U> =\n      promise.Bind(inp, body)\n    member x.Combine (seq1:PromiseSeq<'T>,seq2:PromiseSeq<'T>) =\n      append seq1 seq2\n    member x.While (gd, seq:PromiseSeq<'T>) =\n      if gd() then x.Combine(seq,x.Delay(fun () -> x.While (gd, seq))) else x.Zero()\n    member x.Delay (f:unit -> PromiseSeq<'T>) =\n      promise.Delay(f)\n\n\n  /// Builds an asynchronou sequence using the computation builder syntax\n  let promiseSeq = new PromiseSeqBuilder()\n\n  /// Tries to get the next element of an asynchronous sequence\n  /// and returns either the value or an exception\n  let internal tryNext (input:PromiseSeq<_>) = promise {\n    try\n      let! v = input\n      return Choice1Of2 v\n    with e ->\n      return Choice2Of2 e }\n\n  /// Implements the 'TryWith' functionality for computation builder\n  let rec internal tryWith (input : PromiseSeq<'T>) handler =  promiseSeq {\n    let! v = tryNext input\n    match v with\n    | Choice1Of2 Nil -> ()\n    | Choice1Of2 (Cons (h, t)) ->\n        yield h\n        yield! tryWith t handler\n    | Choice2Of2 rest ->\n        yield! handler rest }\n\n  /// Implements the 'TryFinally' functionality for computation builder\n  let rec internal tryFinally (input : PromiseSeq<'T>) compensation = promiseSeq {\n    let! v = tryNext input\n    match v with\n    | Choice1Of2 Nil ->\n        compensation()\n    | Choice1Of2 (Cons (h, t)) ->\n        yield h\n        yield! tryFinally t compensation\n    | Choice2Of2 e ->\n        compensation()\n        yield! raise e }\n\n  /// Creates an asynchronou sequence that iterates over the given input sequence.\n  /// For every input element, it calls the the specified function and iterates\n  /// over all elements generated by that asynchronous sequence.\n  /// This is the 'bind' operation of the computation expression (exposed using\n  /// the 'for' keyword in promiseSeq computation).\n  let rec collect f (input : PromiseSeq<'T>) : PromiseSeq<'TResult> = promiseSeq {\n    let! v = input\n    match v with\n    | Nil -> ()\n    | Cons(h, t) ->\n        yield! f h\n        yield! collect f t }\n\n\n  // Add additional methods to the 'promiseSeq' computation builder\n  type PromiseSeqBuilder with\n    member x.TryFinally (body: PromiseSeq<'T>, compensation) =\n      tryFinally body compensation\n    member x.TryWith (body: PromiseSeq<_>, handler: (exn -> PromiseSeq<_>)) =\n      tryWith body handler\n    member x.Using (resource:#IDisposable, binder) =\n      tryFinally (binder resource) (fun () ->\n        if box resource <> null then resource.Dispose())\n\n    /// For loop that iterates over a synchronous sequence (and generates\n    /// all elements generated by the asynchronous body)\n    member x.For(seq:seq<'T>, action:'T -> PromiseSeq<'TResult>) =\n      let mutable cur = Unchecked.defaultof<_>\n      let enum: JS.Iterator<'T> = unbox(seq.GetEnumerator())\n      x.While(\n        (fun () -> cur <- enum.next(); not cur.``done``),\n        x.Delay(fun () -> action cur.value.Value))\n\n    /// Asynchronous for loop - for all elements from the input sequence,\n    /// generate all elements produced by the body (asynchronously). See\n    /// also the PromiseSeq.collect function.\n    member x.For (seq:PromiseSeq<'T>, action:'T -> PromiseSeq<'TResult>) =\n      collect action seq\n\n\n  // Add asynchronous for loop to the 'promise' computation builder\n  type Promise.PromiseBuilder with\n    member x.For (seq:PromiseSeq<'T>, action:'T -> JS.Promise<unit>) =\n      promise.Bind(seq, function\n        | Nil -> promise.Zero()\n        | Cons(h, t) -> promise.Combine(action h, x.For(t, action)))\n\n  // --------------------------------------------------------------------------\n  // Additional combinators (implemented as promise/promiseSeq computations)\n\n  /// Builds a new asynchronous sequence whose elements are generated by\n  /// applying the specified function to all elements of the input sequence.\n  ///\n  /// The specified function is asynchronous (and the input sequence will\n  /// be asked for the next element after the processing of an element completes).\n  let mapAsync f (input : PromiseSeq<'T>) : PromiseSeq<'TResult> = promiseSeq {\n    for itm in input do\n      let! v = f itm\n      yield v }\n\n  /// Asynchronously iterates over the input sequence and generates 'x' for\n  /// every input element for which the specified asynchronous function\n  /// returned 'Some(x)'\n  ///\n  /// The specified function is asynchronous (and the input sequence will\n  /// be asked for the next element after the processing of an element completes).\n  let chooseAsync f (input : PromiseSeq<'T>) : PromiseSeq<'R> = promiseSeq {\n    for itm in input do\n      let! v = f itm\n      match v with\n      | Some v -> yield v\n      | _ -> () }\n\n  /// Builds a new asynchronous sequence whose elements are those from the\n  /// input sequence for which the specified function returned true.\n  ///\n  /// The specified function is asynchronous (and the input sequence will\n  /// be asked for the next element after the processing of an element completes).\n  let filterAsync f (input : PromiseSeq<'T>) = promiseSeq {\n    for v in input do\n      let! b = f v\n      if b then yield v }\n\n  /// Asynchronously returns the last element that was generated by the\n  /// given asynchronous sequence (or the specified default value).\n  let rec lastOrDefault def (input : PromiseSeq<'T>) = promise {\n    let! v = input\n    match v with\n    | Nil -> return def\n    | Cons(h, t) -> return! lastOrDefault h t }\n\n  /// Asynchronously returns the first element that was generated by the\n  /// given asynchronous sequence (or the specified default value).\n  let firstOrDefault def (input : PromiseSeq<'T>) = promise {\n    let! v = input\n    match v with\n    | Nil -> return def\n    | Cons(h, _) -> return h }\n\n  /// Aggregates the elements of the input asynchronous sequence using the\n  /// specified 'aggregation' function. The result is an asynchronous\n  /// sequence of intermediate aggregation result.\n  ///\n  /// The aggregation function is asynchronous (and the input sequence will\n  /// be asked for the next element after the processing of an element completes).\n  let rec scanAsync f (state:'TState) (input : PromiseSeq<'T>) = promiseSeq {\n    let! v = input\n    match v with\n    | Nil -> ()\n    | Cons(h, t) ->\n        let! v = f state h\n        yield v\n        yield! t |> scanAsync f v }\n\n  /// Iterates over the input sequence and calls the specified function for\n  /// every value (to perform some side-effect asynchronously).\n  ///\n  /// The specified function is asynchronous (and the input sequence will\n  /// be asked for the next element after the processing of an element completes).\n  let rec iterAsync f (input : PromiseSeq<'T>) = promise {\n    for itm in input do\n      do! f itm }\n\n  /// Returns an asynchronous sequence that returns pairs containing an element\n  /// from the input sequence and its predecessor. Empty sequence is returned for\n  /// singleton input sequence.\n  let rec pairwise (input : PromiseSeq<'T>) = promiseSeq {\n    let! v = input\n    match v with\n    | Nil -> ()\n    | Cons(h, t) ->\n        let prev = ref h\n        for v in t do\n          yield (!prev, v)\n          prev := v }\n\n  /// Aggregates the elements of the input asynchronous sequence using the\n  /// specified 'aggregation' function. The result is an asynchronous\n  /// workflow that returns the final result.\n  ///\n  /// The aggregation function is asynchronous (and the input sequence will\n  /// be asked for the next element after the processing of an element completes).\n  let rec foldAsync f (state:'TState) (input : PromiseSeq<'T>) =\n    input |> scanAsync f state |> lastOrDefault state\n\n  /// Same as PromiseSeq.foldAsync, but the specified function is synchronous\n  /// and returns the result of aggregation immediately.\n  let rec fold f (state:'TState) (input : PromiseSeq<'T>) =\n    foldAsync (fun st v -> f st v |> promise.Return) state input\n\n  /// Same as PromiseSeq.scanAsync, but the specified function is synchronous\n  /// and returns the result of aggregation immediately.\n  let rec scan f (state:'TState) (input : PromiseSeq<'T>) =\n    scanAsync (fun st v -> f st v |> promise.Return) state input\n\n  /// Same as PromiseSeq.mapAsync, but the specified function is synchronous\n  /// and returns the result of projection immediately.\n  let map f (input : PromiseSeq<'T>) =\n    mapAsync (f >> promise.Return) input\n\n  /// Same as PromiseSeq.iterAsync, but the specified function is synchronous\n  /// and performs the side-effect immediately.\n  let iter f (input : PromiseSeq<'T>) =\n    iterAsync (f >> promise.Return) input\n\n  /// Same as PromiseSeq.chooseAsync, but the specified function is synchronous\n  /// and processes the input element immediately.\n  let choose f (input : PromiseSeq<'T>) =\n    chooseAsync (f >> promise.Return) input\n\n  /// Same as PromiseSeq.filterAsync, but the specified predicate is synchronous\n  /// and processes the input element immediately.\n  let filter f (input : PromiseSeq<'T>) =\n    filterAsync (f >> promise.Return) input\n\n  // /// Combines two asynchronous sequences into a sequence of pairs.\n  // /// The values from sequences are retrieved in parallel.\n  // let rec zip (input1 : PromiseSeq<'T1>) (input2 : PromiseSeq<'T2>) : PromiseSeq<_> = promise {\n  //   let! ft = input1 |> JS.Promise.StartChild\n  //   let! s = input2\n  //   let! f = ft\n  //   match f, s with\n  //   | Cons(hf, tf), Cons(hs, ts) ->\n  //       return Cons( (hf, hs), zip tf ts)\n  //   | _ -> return Nil }\n\n  /// Returns elements from an asynchronous sequence while the specified\n  /// predicate holds. The predicate is evaluated asynchronously.\n  let rec takeWhileAsync p (input : PromiseSeq<'T>) : PromiseSeq<_> = promise {\n    let! v = input\n    match v with\n    | Cons(h, t) ->\n        let! res = p h\n        if res then\n          return Cons(h, takeWhileAsync p t)\n        else return Nil\n    | Nil -> return Nil }\n\n  /// Skips elements from an asynchronous sequence while the specified\n  /// predicate holds and then returns the rest of the sequence. The\n  /// predicate is evaluated asynchronously.\n  let rec skipWhileAsync p (input : PromiseSeq<'T>) : PromiseSeq<_> = promise {\n    let! v = input\n    match v with\n    | Cons(h, t) ->\n        let! res = p h\n        if res then return! skipWhileAsync p t\n        else return! t\n    | Nil -> return Nil }\n\n  /// Returns elements from an asynchronous sequence while the specified\n  /// predicate holds. The predicate is evaluated synchronously.\n  let rec takeWhile p (input : PromiseSeq<'T>) =\n    takeWhileAsync (p >> promise.Return) input\n\n  /// Skips elements from an asynchronous sequence while the specified\n  /// predicate holds and then returns the rest of the sequence. The\n  /// predicate is evaluated asynchronously.\n  let rec skipWhile p (input : PromiseSeq<'T>) =\n    skipWhileAsync (p >> promise.Return) input\n\n  /// Returns the first N elements of an asynchronous sequence\n  let rec take count (input : PromiseSeq<'T>) : PromiseSeq<_> = promise {\n    if count > 0 then\n      let! v = input\n      match v with\n      | Cons(h, t) ->\n          return Cons(h, take (count - 1) t)\n      | Nil -> return Nil\n    else return Nil }\n\n  /// Skips the first N elements of an asynchronous sequence and\n  /// then returns the rest of the sequence unmodified.\n  let rec skip count (input : PromiseSeq<'T>) : PromiseSeq<_> = promise {\n    if count > 0 then\n      let! v = input\n      match v with\n      | Cons(h, t) ->\n          return! skip (count - 1) t\n      | Nil -> return Nil\n    else return! input }\n"]}